// Service Worker para Background Sync e Notifica√ß√µes
console.log('üöÄ Service Worker carregado');

// üéØ CACHE PARA PERSIST√äNCIA DE LOGIN iOS PWA
let loginDataCache = null;

const CACHE_NAME = 'refeicoes-pwa-v1';
const urlsToCache = [
    '/sistema-pedidos.html',
    '/api/teste-conexao',
    '/manifest.json'
];

// Detectar se √© iOS (sem usar navigator/window no SW)
const isIOS = false; // Simplificado para Service Worker
const isStandalone = false; // Simplificado para Service Worker

console.log('üì± Ambiente Service Worker:', { isIOS, isStandalone });

// Configurar notifica√ß√µes di√°rias √†s 19:30
function scheduleNotification() {
    const now = new Date();
    const targetTime = new Date();
    targetTime.setHours(19, 30, 0, 0); // 19:30 (7:30 PM)
    
    // Se j√° passou das 19:30 hoje, agendar para amanh√£
    if (now > targetTime) {
        targetTime.setDate(targetTime.getDate() + 1);
    }
    
    const timeUntilNotification = targetTime.getTime() - now.getTime();
    
    console.log('‚è∞ Pr√≥xima notifica√ß√£o em:', new Date(targetTime).toLocaleString('pt-BR'));
    
    setTimeout(() => {
        showNotification();
        // Reagendar para o pr√≥ximo dia
        scheduleNotification();
    }, timeUntilNotification);
}

// Mostrar notifica√ß√£o
function showNotification() {
    const options = {
        title: 'üçΩÔ∏è Hora do Pedido de Refei√ß√£o!',
        body: 'N√£o esque√ßa de fazer seu pedido de refei√ß√£o para amanh√£! üòã',
        icon: '/icon-192x192.png',
        badge: '/icon-192x192.png',
        tag: 'meal-reminder',
        requireInteraction: true,
        actions: [
            {
                action: 'fazer-pedido',
                title: 'üçΩÔ∏è Fazer Pedido'
            },
            {
                action: 'lembrar-depois',
                title: '‚è∞ Lembrar em 30min'
            }
        ],
        data: {
            url: '/sistema-pedidos.html',
            timestamp: new Date().toISOString()
        }
    };
    
    self.registration.showNotification(options.title, options);
    console.log('üîî Notifica√ß√£o de refei√ß√£o enviada √†s', new Date().toLocaleString('pt-BR'));
}

// Iniciar agendamento quando o SW √© ativado
self.addEventListener('activate', event => {
    console.log('‚ö° Service Worker ativado');
    scheduleNotification(); // Iniciar notifica√ß√µes
    // ... resto do c√≥digo de ativa√ß√£o
});

// Instalar Service Worker
self.addEventListener('install', event => {
    console.log('üì¶ Service Worker instalando...');
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => {
                console.log('üíæ Cache criado');
                return cache.addAll(urlsToCache);
            })
            .catch(err => console.log('‚ùå Erro no cache:', err))
    );
    
    // Para iOS PWAs, aguardar ativa√ß√£o manual (n√£o for√ßar)
    if (isIOS) {
        console.log('üçé iOS detectado - Service Worker instalado (aguardando ativa√ß√£o)');
        // Removido self.skipWaiting() para evitar recargas autom√°ticas
    }
});

// Ativar Service Worker
self.addEventListener('activate', event => {
    console.log('‚ö° Service Worker ativado');
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    if (cacheName !== CACHE_NAME) {
                        console.log('üóëÔ∏è Removendo cache antigo:', cacheName);
                        return caches.delete(cacheName);
                    }
                })
            );
        }).then(() => {
            // Toma controle suave das p√°ginas (sem for√ßar reload)
            console.log('üéØ Service Worker assumindo controle suave das p√°ginas');
            return self.clients.claim();
        })
    );
});

// Interceptar requests
self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                // Cache hit - retorna response do cache
                if (response) {
                    return response;
                }
                return fetch(event.request);
            })
    );
});

// üîÑ BACKGROUND SYNC - Esta √© a m√°gica!
self.addEventListener('sync', event => {
    console.log('üîÑ Background Sync triggered:', event.tag);
    
    if (event.tag === 'database-sync') {
        event.waitUntil(processDatabaseQueueBackground());
    } else if (event.tag === 'temperatura-sync') {
        event.waitUntil(processTemperaturaQueueBackground());
    }
});

// Fun√ß√£o para processar fila em background
async function processDatabaseQueueBackground() {
    console.log('üíæ Processando fila do banco em background...');
    
    try {
        // Buscar dados da fila no IndexedDB/localStorage
        const databaseQueue = await getDatabaseQueue();
        
        if (databaseQueue.length === 0) {
            console.log('‚úÖ Fila vazia - nada para processar');
            return;
        }
        
        console.log(`üì§ Processando ${databaseQueue.length} pedidos em background`);
        
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < databaseQueue.length; i++) {
            const item = databaseQueue[i];
            
            try {
                // Determinar URL base dinamicamente
                const baseUrl = await getServerBaseUrl();
                
                const response = await fetch(`${baseUrl}/api/salvar-pedido`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(item.data)
                });
                
                const result = await response.json();
                
                if (result.error) {
                    console.error(`‚ùå Erro ao enviar pedido da fila:`, result.message);
                    errorCount++;
                } else {
                    console.log(`‚úÖ Pedido enviado em background: ${item.data.tipo_refeicao}`);
                    successCount++;
                }
                
            } catch (error) {
                console.error(`‚ùå Erro de conex√£o ao enviar pedido:`, error);
                errorCount++;
            }
        }
        
        // Limpar fila apenas se todos foram processados com sucesso
        if (errorCount === 0) {
            await clearDatabaseQueue();
            console.log('üóëÔ∏è Fila limpa ap√≥s sucesso em background');
            
            // Mostrar notifica√ß√£o de sucesso
            if (successCount > 0) {
                self.registration.showNotification('‚úÖ Pedidos Enviados', {
                    body: `${successCount} pedido(s) foram enviados automaticamente!`,
                    icon: '/icon-192x192.png',
                    badge: '/badge-72x72.png',
                    tag: 'pedidos-enviados'
                });
            }
        } else {
            console.log(`‚ö†Ô∏è ${errorCount} pedidos permaneceram na fila`);
        }
        
    } catch (error) {
        console.error('‚ùå Erro no background sync:', error);
    }
}

// Fun√ß√£o para processar fila de temperatura em background
async function processTemperaturaQueueBackground() {
    console.log('üå°Ô∏è Processando fila de temperatura em background...');
    
    try {
        // Buscar dados da fila de temperatura
        const temperaturaQueue = await getTemperaturaQueue();
        
        if (temperaturaQueue.length === 0) {
            console.log('‚úÖ Fila de temperatura vazia - nada para processar');
            return;
        }
        
        console.log(`üì§ Processando ${temperaturaQueue.length} aferi√ß√£o(√µes) de temperatura em background`);
        
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < temperaturaQueue.length; i++) {
            const item = temperaturaQueue[i];
            
            try {
                // Determinar URL base dinamicamente
                const baseUrl = await getServerBaseUrl();
                
                const response = await fetch(`${baseUrl}/api/afericao-temperatura`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(item)
                });
                
                const result = await response.json();
                
                if (result.error) {
                    console.error(`‚ùå Erro ao enviar aferi√ß√£o da fila:`, result.message);
                    errorCount++;
                } else {
                    console.log(`‚úÖ Aferi√ß√£o enviada em background: Pedido ${item.pedido_id}`);
                    successCount++;
                }
                
            } catch (error) {
                console.error(`‚ùå Erro de conex√£o ao enviar aferi√ß√£o:`, error);
                errorCount++;
            }
        }
        
        // Limpar fila apenas se todos foram processados com sucesso
        if (errorCount === 0) {
            await clearTemperaturaQueue();
            console.log('üóëÔ∏è Fila de temperatura limpa ap√≥s sucesso em background');
            
            // Mostrar notifica√ß√£o de sucesso
            if (successCount > 0) {
                self.registration.showNotification('üå°Ô∏è Aferi√ß√µes Enviadas', {
                    body: `${successCount} aferi√ß√£o(√µes) de temperatura foram enviadas automaticamente!`,
                    icon: '/icon-192x192.png',
                    badge: '/badge-72x72.png',
                    tag: 'temperaturas-enviadas'
                });
            }
        } else {
            console.log(`‚ö†Ô∏è ${errorCount} aferi√ß√µes permaneceram na fila`);
        }
        
    } catch (error) {
        console.error('‚ùå Erro no background sync de temperatura:', error);
    }
}

// Fun√ß√£o para obter fila de temperatura
async function getTemperaturaQueue() {
    // Usar dados sincronizados pela p√°gina principal
    return self.temperaturaQueueData || [];
}

// Fun√ß√£o para limpar fila de temperatura
async function clearTemperaturaQueue() {
    // Comunicar com p√°gina principal para limpar
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
        client.postMessage({
            type: 'CLEAR_TEMPERATURA_QUEUE'
        });
    });
    
    // Limpar dados locais tamb√©m
    self.temperaturaQueueData = [];
}

// Fun√ß√£o para obter fila do localStorage via message
async function getDatabaseQueue() {
    // Usar dados sincronizados pela p√°gina principal
    return self.databaseQueueData || [];
}

// Fun√ß√£o para limpar fila
async function clearDatabaseQueue() {
    // Comunicar com p√°gina principal para limpar
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
        client.postMessage({
            type: 'CLEAR_DATABASE_QUEUE'
        });
    });
    
    // Limpar dados locais tamb√©m
    self.databaseQueueData = [];
}

// Fun√ß√£o para obter URL base do servidor
async function getServerBaseUrl() {
    // Verificar se √© localhost ou ngrok
    const hostname = self.location.hostname;
    
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://localhost:8082';
    }
    
    // Para ngrok ou outros, usar a origem atual
    return self.location.origin;
}

// Escutar mensagens da p√°gina principal
self.addEventListener('message', event => {
    if (event.data.type === 'UPDATE_DATABASE_QUEUE') {
        // Atualizar dados da fila localmente no SW
        self.databaseQueueData = event.data.queue;
        console.log('üìù Fila de pedidos atualizada no SW:', self.databaseQueueData?.length || 0);
    } else if (event.data.type === 'UPDATE_TEMPERATURA_QUEUE') {
        // Atualizar dados da fila de temperatura localmente no SW
        self.temperaturaQueueData = event.data.queue;
        console.log('üå°Ô∏è Fila de temperatura atualizada no SW:', self.temperaturaQueueData?.length || 0);
    } else if (event.data.type === 'CLEAR_TEMPERATURA_QUEUE') {
        // Limpar fila de temperatura
        self.temperaturaQueueData = [];
        console.log('üóëÔ∏è Fila de temperatura limpa no SW');
    } else if (event.data.type === 'FORCE_BACKGROUND_SYNC') {
        // For√ßar processamento imediato da fila
        console.log('üöÄ Background sync for√ßado pelo app');
        processDatabaseQueueBackground();
        processTemperaturaQueueBackground();
    } else if (event.data.type === 'KEEP_ALIVE') {
        // Manter Service Worker ativo
        console.log('üíì Service Worker mantido vivo:', new Date().toLocaleTimeString());
    } else if (event.data.type === 'SAVE_LOGIN') {
        // üéØ SALVAR LOGIN NO SERVICE WORKER PARA iOS PWA
        loginDataCache = event.data.data;
        console.log('üíæ Login salvo no Service Worker para persist√™ncia iOS:', loginDataCache);
    } else if (event.data.type === 'CLEAR_LOGIN') {
        // üóëÔ∏è LIMPAR LOGIN DO SERVICE WORKER
        loginDataCache = null;
        console.log('üö™ Login removido do Service Worker');
    } else if (event.data.type === 'GET_LOGIN') {
        // üì§ RETORNAR LOGIN SALVO NO SERVICE WORKER
        event.ports[0].postMessage({
            type: 'LOGIN_DATA',
            data: loginDataCache
        });
        console.log('üì§ Login enviado do Service Worker:', loginDataCache ? 'encontrado' : 'n√£o encontrado');
    }
});

// Manter Service Worker ativo - eventos especiais
self.addEventListener('sync', event => {
    console.log('üîÑ Evento sync recebido:', event.tag);
    if (event.tag === 'database-queue-sync') {
        event.waitUntil(processDatabaseQueueBackground());
    }
});

// Interceptar fechamento do app para for√ßar sync
self.addEventListener('beforeunload', event => {
    console.log('‚ö†Ô∏è App fechando - for√ßando sync');
    self.registration.sync.register('database-queue-sync');
});

// Periodic Background Sync (se suportado)
self.addEventListener('periodicsync', event => {
    if (event.tag === 'database-queue-periodic') {
        console.log('‚è∞ Sync peri√≥dico ativado');
        event.waitUntil(processDatabaseQueueBackground());
    }
});

// Para iOS PWAs: Eventos especiais para manter atividade
if (isIOS) {
    // Interceptar push notifications para iOS
    self.addEventListener('push', event => {
        console.log('üçé Push recebido no iOS PWA');
        event.waitUntil(processDatabaseQueueBackground());
    });
    
    // Interceptar quando volta do background (iOS)
    self.addEventListener('focus', event => {
        console.log('üçé iOS PWA voltou ao foco');
        processDatabaseQueueBackground();
    });
    
    // Timer interno para iOS (tentativa de manter ativo)
    setInterval(() => {
        const now = new Date();
        console.log('üçé iOS SW Keep-alive:', now.toLocaleTimeString());
        
        // Verificar se h√° itens na fila e tentar processar
        if (self.databaseQueueData && self.databaseQueueData.length > 0) {
            console.log('üçé iOS: Processando fila automaticamente');
            processDatabaseQueueBackground();
        }
    }, 60000); // A cada 1 minuto
}

// Handler para cliques nas notifica√ß√µes
self.addEventListener('notificationclick', event => {
    console.log('üîî Notifica√ß√£o clicada:', event.action);
    
    event.notification.close();
    
    if (event.action === 'fazer-pedido') {
        // Abrir o sistema de pedidos
        event.waitUntil(
            clients.openWindow('/sistema-pedidos.html')
        );
    } else if (event.action === 'lembrar-depois') {
        // Reagendar notifica√ß√£o em 30 minutos
        setTimeout(() => {
            showNotification();
        }, 30 * 60 * 1000); // 30 minutos
        
        console.log('‚è∞ Notifica√ß√£o reagendada para 30 minutos');
    } else {
        // Clique no corpo da notifica√ß√£o - abrir o app
        event.waitUntil(
            clients.openWindow('/sistema-pedidos.html')
        );
    }
});

// Handler para fechar notifica√ß√£o
self.addEventListener('notificationclose', event => {
    console.log('üîî Notifica√ß√£o fechada');
});

console.log('‚úÖ Service Worker configurado com Background Sync e Notifica√ß√µes');